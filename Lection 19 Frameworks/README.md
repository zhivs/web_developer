# Основы работы с Python web-фреймворками

## 1. Обзор протокола HTTP

### Что такое HTTP?

**Определение**:  
HTTP — это аббревиатура от HyperText Transfer Protocol, что переводится как "Протокол передачи гипертекста". Это основной способ, по которому устройства в интернете обмениваются данными. Представьте HTTP как правила общения между вашим браузером (или приложением) и веб-сервером. Без HTTP веб-страницы не загружались бы, формы не отправлялись, и приложения не могли бы получать данные из интернета. HTTP — это основа всего веба, как язык, на котором говорят компьютеры в сети.

**Ключевые характеристики**:  
HTTP работает по простым правилам, которые делают его надёжным и универсальным. Давайте разберём их по порядку, с аналогиями, чтобы было проще понять.

- **Клиент-серверная модель**:  
  Это как разговор между клиентом (вами, когда вы заходите на сайт через браузер или мобильное приложение) и сервером (компьютером, где хранится сайт). Клиент отправляет запрос ("Привет, покажи мне эту страницу!"), а сервер отвечает ("Вот она!"). Клиент — это инициатор, сервер — исполнитель. Аналогия: вы звоните в службу доставки (клиент), а ресторан готовит и отправляет еду (сервер).

- **Stateless (без состояния)**:  
  HTTP не помнит предыдущие разговоры. Каждый запрос полностью независим от других. Если вы зашли на сайт, добавили товар в корзину, а потом обновили страницу — сервер не "помнит" вашу корзину, если не использовать дополнительные инструменты (о них ниже). Аналогия: это как звонок в службу поддержки, где каждый раз вы начинаете разговор заново, без ссылки на прошлые звонки. Это упрощает систему, но иногда требует хитростей, чтобы "запоминать" информацию (например, с помощью куки или сессий).

- **Методы HTTP**:  
  Методы — это "команды", которые клиент отправляет серверу, чтобы указать, что делать. Вот основные, с простыми объяснениями:
  - **GET**: Получение данных. Используется, когда вы просто хотите посмотреть информацию, например, открыть страницу или получить список товаров. Не меняет ничего на сервере. Аналогия: "Покажи мне меню ресторана".
  - **POST**: Отправка данных на сервер для создания чего-то нового. Например, когда вы регистрируетесь на сайте или отправляете комментарий. Аналогия: "Закажи мне пиццу и добавь её в мой заказ".
  - **PUT/PATCH**: Обновление данных. PUT заменяет всю информацию целиком, PATCH меняет только часть. Например, изменить пароль или обновить профиль. Аналогия: "Измените адрес доставки в моём заказе" (PATCH — только адрес, PUT — весь заказ заново).
  - **DELETE**: Удаление данных. Например, удалить пост или аккаунт. Аналогия: "Отмените мой заказ".

- **Коды ответов**:  
  Когда сервер отвечает, он всегда добавляет номер — код состояния, чтобы сказать, как прошёл запрос. Это как статус доставки: "Доставлено", "Не найдено" или "Ошибка". Вот распространённые:
  - **200 OK**: Всё прошло успешно. Данные получены или действие выполнено.
  - **404 Not Found**: То, что вы просили, не существует. Например, если вы ввели неправильный адрес страницы.
  - **500 Internal Server Error**: Проблема на стороне сервера, как если бы ресторан был закрыт из-за технических неполадок.
  - Другие полезные: **201 Created** (что-то новое создано, например, после POST), **403 Forbidden** (нет доступа, как "Вход запрещён"), **301 Moved Permanently** (ресурс переехал на новый адрес).

**Почему это важно?**  
HTTP — это фундамент веб-разработки. Если вы учитесь программировать сайты или API, понимание HTTP поможет понять, почему браузер показывает ошибку или как данные передаются между приложениями. Без технических знаний: подумайте о HTTP как о почтовой службе интернета — она доставляет "письма" (запросы) и "посылки" (ответы) по правилам.

---

### Структура HTTP-запроса и ответа

HTTP-запрос и ответ — это как конверт с письмом: есть адрес, заголовки (метки) и само содержимое. Давайте разберём их шаг за шагом, с аналогиями.

- **Структура запроса**:  
  Запрос — это то, что клиент отправляет серверу. Он состоит из:
  - **Строка запроса**: Первая строка, где указан метод, URL и версия HTTP. Например: `GET /api/users HTTP/1.1`. Это как адрес на конверте: "Кому, что и как".
  - **Заголовки (Headers)**: Метаданные, как дополнительные пометки на конверте. Они говорят серверу о формате данных, языке или авторизации. Примеры:
    - `Host: example.com` — куда отправить запрос.
    - `Content-Type: application/json` — данные в формате JSON (как "Это письмо на английском").
    - `Accept: application/json` — клиент хочет ответ в JSON.
  - **Тело (Body)**: Само содержимое, если нужно отправить данные (например, в POST). Это может быть JSON, текст или файлы. Если метод GET, тела обычно нет.
  - **URL и параметры запроса**: URL — это адрес, как `/api/users`. Параметры — дополнительные детали в URL, например, `/api/users?id=123` (path-параметры) или `/api/users?age=25&name=John` (query-параметры после `?`).

- **Структура ответа**:  
  Ответ — это что сервер отправляет обратно. Он похож на запрос, но с кодом состояния.
  - **Строка статуса**: Первая строка, например: `HTTP/1.1 200 OK`.
  - **Заголовки**: Похожи на запрос, но могут включать `Content-Length` (размер тела) или `Set-Cookie` (установка куки).
  - **Тело**: Сам ответ, например, HTML для страницы, JSON с данными или изображение.

**Аналогия для всего**: Запрос — это заказ в ресторане (метод — что заказать, заголовки — пожелания, тело — детали заказа). Ответ — еда на подносе (код — "Готово!", заголовки — счёт, тело — сама еда).

#### **Версии HTTP**:  

##### . HTTP/1.1: 
Классическая, но медленная, так как обрабатывает запросы по очереди

HTTP/1.1 — это версия протокола, появившаяся в 1997 году и до сих пор широко используемая. Это "классика" веба, которая работает надёжно, но не 
всегда быстро. Она обрабатывает запросы последовательно, то есть один за другим.
Как это работает?
Когда ваш браузер запрашивает веб-страницу (например, открывает сайт), он отправляет запросы на сервер: "Дай мне HTML-код страницы", "Дай мне картинку", "Дай мне CSS-файл". В HTTP/1.1 сервер отвечает на каждый запрос по очереди. Это как очередь в почтовом отделении: пока одно письмо не обработано, следующее ждёт.


##### HTTP/2 
Это улучшенная версия, выпущенная в 2015 году. Она решает проблемы HTTP/1.1, делая загрузку страниц быстрее за счёт параллельной обработки запросов. 

Это как переход от одного официанта к целой команде, которая работает одновременно.
HTTP/2 использует одно соединение между браузером и сервером, но позволяет отправлять и получать несколько запросов и ответов одновременно (это называется мультиплексирование). Также HTTP/2 сжимает заголовки и лучше управляет приоритетами (например, сначала грузит HTML, потом картинки).

**Ключевые улучшения**

Мультиплексирование: Вместо очереди запросов HTTP/2 отправляет их параллельно по одному соединению. Это как несколько линий доставки в одном канале.

Сжатие заголовков: Заголовки (например, Content-Type) сжимаются, чтобы уменьшить объём данных. Это как писать письмо короче, но с тем же смыслом.

Приоритизация: HTTP/2 может указать, какие файлы важнее (например, CSS грузится раньше второстепенных картинок).

Server Push: Сервер может заранее отправить данные, которые, по его мнению, понадобятся клиенту. Например, если вы запросили HTML, сервер сразу отправит CSS и картинки, не дожидаясь отдельных запросов. Это как повар, который заранее готовит гарнир, зная, что вы его закажете.


##### HTTP/3 

Это новейшая версия протокола, которая начала активно внедряться в 2020-х годах. Она ещё быстрее, потому что использует другой способ передачи данных — UDP вместо TCP, и включает встроенное шифрование. HTTP/3 основан на протоколе QUIC, разработанном Google.


TTP/3 сохраняет все преимущества HTTP/2 (мультиплексирование, сжатие заголовков), но использует UDP (User Datagram Protocol) вместо TCP (Transmission Control Protocol). TCP — это надёжный, но медленный протокол, который проверяет, дошли ли все данные, и пересылает их, если что-то потерялось. UDP быстрее, потому что не тратит время на такие проверки, а QUIC добавляет свои механизмы для надёжности.

###### Ключевые улучшения HTTP/3:

- UDP через QUIC: UDP быстрее, так как не ждёт подтверждений доставки. QUIC добавляет шифрование и механизмы для восстановления потерянных данных, делая UDP надёжным.

- Быстрое установление соединения: В TCP нужно несколько "рукопожатий" (обменов данными), чтобы начать передачу. QUIC делает это быстрее, что особенно заметно на мобильных сетях.

- Устойчивость к потерям: Если часть данных теряется, HTTP/3 быстрее восстанавливается, так как потоки данных независимы. В HTTP/2 потеря одного пакета могла замедлить всё соединение.

- Встроенное шифрование: HTTP/3 всегда использует TLS (как HTTPS), так что данные защищены без дополнительных настроек.

---

### Примеры HTTP-запросов

Давайте посмотрим на примеры в текстовом формате (как они выглядят "под капотом" в сети). Вы можете протестировать их в инструментах вроде Postman или curl в терминале.

**Простой пример: GET-запрос**  
Это запрос на получение данных. Нет тела, только заголовки.
```plaintext
GET /api/users HTTP/1.1
Host: example.com
Accept: application/json
```

**Разберём пример**:
- `GET` — метод: получить данные.
- `/api/users` — URL: список пользователей.
- `Host: example.com` — сервер.
- `Accept: application/json` — хочу ответ в JSON.
- Возможный ответ: `HTTP/1.1 200 OK` с телом `[{"id":1, "name":"John"}]`.

**Расширенный пример: POST-запрос**  
Это для отправки данных. Есть тело.
```plaintext
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 45

{"name": "John Doe", "email": "john@example.com"}
```

**Разберём пример**:
- `POST` — метод: создать нового пользователя.
- `Content-Type: application/json` — тело в JSON.
- `Content-Length: 45` — размер тела (45 байт).
- Тело: данные о пользователе в JSON.
- Возможный ответ: `HTTP/1.1 201 Created` с телом `{"id": 123, "name": "John Doe"}`.

**Ещё один пример: PUT-запрос**  
Для обновления.
```plaintext
PUT /api/users/123 HTTP/1.1
Host: example.com
Content-Type: application/json
Content-Length: 28

{"name": "Jane Doe"}
```

- Здесь мы обновляем пользователя с ID 123, меняя только имя.

---

### Дополнительные компоненты HTTP

Чтобы материал был полным, добавим важные вещи, которые часто встречаются в реальной разработке. Я объясню их просто, без сложностей.

#### 1. **HTTPS (Безопасный HTTP)**

**Что это?**  
HTTPS — это HTTP с шифрованием. Добавляет "S" от Secure. Использует SSL/TLS сертификаты, чтобы защитить данные от перехвата. Аналогия: HTTP — открытая почтовая карточка, HTTPS — запечатанный конверт с замком.

**Почему важно?**  
Без HTTPS хакеры могут украсть пароли или карты. Все современные сайты используют HTTPS (смотрите на замочек в браузере). В запросах это выглядит так же, но URL начинается с `https://`.

#### 2. **Куки (Cookies)**

**Что это?**  
Куки — маленькие файлы, которые сервер отправляет клиенту, чтобы "запомнить" информацию. Поскольку HTTP stateless, куки помогают сохранять состояние, например, логин. Аналогия: это как записка в кармане — сервер даёт её вам, и вы отправляете обратно при следующем запросе.

**Пример**: В ответе сервер добавляет `Set-Cookie: session_id=abc123`. В следующем запросе клиент добавляет `Cookie: session_id=abc123`.

#### 3. **Сессии и авторизация**

**Что это?**  
Сессии — способ управлять состоянием с помощью куки или токенов (например, JWT). Авторизация — проверка, кто вы (логин/пароль) или что вы можете делать (токены). Аналогия: сессия — как билет в кино, который проверяют на входе.

**Пример заголовка**: `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...` (токен для доступа).

#### 4. **CORS (Cross-Origin Resource Sharing)**

**Что это?**  
CORS — правила, которые позволяют или запрещают запросы с других доменов. Браузеры блокируют запросы с чужих сайтов для безопасности. Сервер добавляет заголовки вроде `Access-Control-Allow-Origin: *` (разрешить всем).

**Почему нужно?**  
Если ваш фронтенд (сайт) на одном домене, а API на другом, без CORS ничего не сработает.

#### 5. **Кэширование**

**Что это?**  
Кэширование — хранение ответов, чтобы не запрашивать заново. Заголовки вроде `Cache-Control: max-age=3600` говорят: "Храни это 1 час". Аналогия: вместо того чтобы каждый раз идти в магазин, берёте из холодильника.

---

## 2. Обзор ключевых компонентов архитектуры веб-фреймворков на примере FastAPI

### Что такое FastAPI?

FastAPI — это современный веб-фреймворк для создания веб-приложений на языке программирования Python. Представьте его как набор инструментов, которые помогают быстро и удобно создавать веб-сайты или API (интерфейсы для обмена данными между программами). FastAPI особенно популярен, потому что он:

- **Быстрый**: использует асинхронное программирование (async/await), что позволяет обрабатывать множество запросов одновременно, как если бы официант в ресторане мог одновременно обслуживать несколько столиков, не заставляя их ждать.
- **Прост в использовании**: благодаря поддержке типизации (через библиотеку Pydantic) и автоматической генерации документации, даже новички могут быстро разобраться.
- **Автоматизирует рутину**: FastAPI сам создаёт документацию для вашего API, чтобы другие разработчики могли легко понять, как с ним работать.

**Асинхронное программирование** — это способ писать код, который позволяет выполнять задачи параллельно. Например, если вы заказываете еду в кафе и официант не ждёт, пока повар приготовит ваш заказ, а сразу идёт обслуживать других клиентов, это похоже на асинхронность. В FastAPI это помогает обрабатывать запросы от пользователей быстрее.

**Pydantic** — это библиотека, которая помогает проверять, что данные, которые приходят в ваше приложение (например, имя или email), правильные и соответствуют ожидаемому формату. Это как проверка билета на входе в кинотеатр: если билет не соответствует, вас не пустят.

**Автоматическая документация** — это как меню в ресторане: FastAPI автоматически создаёт страницу, где описаны все доступные функции вашего API, и даже позволяет протестировать их прямо в браузере.

---

### Ключевые компоненты веб-фреймворков

Веб-фреймворки, такие как FastAPI, состоят из нескольких важных частей, которые работают вместе, чтобы ваше приложение могло принимать запросы от пользователей, обрабатывать их и отправлять ответы. Давайте разберём эти части по порядку, добавим примеры и объясним их так, чтобы всё было понятно.

#### 1. **Маршрутизация**

**Что это?**  
Маршрутизация — это как указатели на дороге, которые направляют запросы пользователей (например, когда кто-то заходит на сайт или отправляет данные) к нужной части вашего кода. В FastAPI вы задаёте **URL-адреса** (например, `/users/123` или `/items`) и связываете их с функциями, которые будут обрабатывать эти запросы.

**Простыми словами**: представьте, что ваш веб-сервер — это почтовое отделение. Каждый запрос от пользователя — это письмо с адресом (URL). Маршрутизация решает, в какой ящик (функцию) отправить это письмо, чтобы его обработали.

**Пример в FastAPI**:
```python
from fastapi import FastAPI
app = FastAPI()

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id, "name": "John Doe", "email": "john@example.com"}
```

**Разберём пример**:
- `@app.get("/users/{user_id}")` — это декоратор, который говорит FastAPI: "Если пользователь зайдёт по адресу `/users/123`, вызови функцию `get_user`".
- `{user_id}` — это переменная часть URL. Например, если пользователь зайдёт на `/users/123`, то `user_id` будет равно 123.
- `async def` — это ключевое слово, которое делает функцию асинхронной, чтобы она могла работать параллельно с другими задачами.
- Функция возвращает словарь (в формате JSON), который FastAPI автоматически превращает в ответ для пользователя. Например, если пользователь зайдёт на `/users/123`, он получит: `{"user_id": 123, "name": "John Doe", "email": "john@example.com"}`.

**Расширение: Query-параметры и валидация**  
Query-параметры — это дополнительные данные, которые пользователь передаёт через URL, например: `/search/?q=книга`. Они обычно идут после знака `?` в адресе. FastAPI позволяет легко работать с ними и проверять их правильность.

**Пример с query-параметрами**:
```python
from fastapi import Query

@app.get("/search/")
async def search_users(q: str = Query(None, min_length=3, max_length=50)):
    if q:
        return {"query": q, "results": [{"name": "John"}, {"name": "Jane"}]}
    return {"results": []}
```

**Разберём пример**:
- `q: str = Query(None, min_length=3, max_length=50)` — это параметр `q`, который пользователь передаёт через URL (например, `/search/?q=книга`). 
- `Query(None, min_length=3, max_length=50)` говорит FastAPI, что `q` — это строка, которая может быть пустой (`None`), но если она есть, то должна быть длиной от 3 до 50 символов.
- Если пользователь отправит `q` короче 3 символов, FastAPI автоматически вернёт ошибку.
- Если `q` передан, функция возвращает результаты поиска, иначе — пустой список.

**Для чего это нужно?**  
Маршрутизация позволяет вашему приложению понимать, какой запрос куда направить. Например, если у вас есть интернет-магазин, один URL может показывать список товаров, а другой — информацию о конкретном товаре.

---

#### 2. **Обработчик запросов**

**Что это?**  
Обработчик запросов — это функция, которая выполняется, когда пользователь отправляет запрос на определённый URL. Она берёт данные из запроса (например, параметры или заголовки) и возвращает ответ, который отправляется пользователю.

**Простыми словами**: это как повар в ресторане, который получает заказ (запрос) и готовит блюдо (ответ) по рецепту (коду функции).

**Пример в FastAPI**:
```python
@app.get("/items/")
async def read_items(skip: int = 0, limit: int = 10):
    items = [{"id": i, "name": f"Item {i}"} for i in range(skip, skip + limit)]
    return {"items": items, "skip": skip, "limit": limit}
```

**Разберём пример**:
- `@app.get("/items/")` — говорит FastAPI, что эта функция обрабатывает запросы на URL `/items/`.
- `skip: int = 0` и `limit: int = 10` — это параметры, которые пользователь может передать через URL, например: `/items/?skip=5&limit=3`. Если их не передать, они по умолчанию равны 0 и 10.
- Функция создаёт список из элементов (в данном случае, имён вроде "Item 5", "Item 6", "Item 7") и возвращает его в виде JSON.
- Например, если пользователь зайдёт на `/items/?skip=0&limit=2`, он получит: `{"items": [{"id": 0, "name": "Item 0"}, {"id": 1, "name": "Item 1"}], "skip": 0, "limit": 2}`.

**Расширение: Работа с заголовками и обработка ошибок**  
Заголовки — это дополнительные данные, которые приходят с запросом, например, токен авторизации. FastAPI позволяет их проверять и обрабатывать ошибки, если что-то пошло не так.

**Пример с заголовками**:
```python
from fastapi import Header, HTTPException

@app.get("/protected/")
async def protected_route(authorization: str = Header(None)):
    if authorization != "Bearer secret-token":
        raise HTTPException(status_code=401, detail="Unauthorized")
    return {"message": "Access granted"}
```

**Разберём пример**:
- `Header(None)` — говорит FastAPI, что мы ожидаем заголовок `Authorization` в запросе. Если его нет, он будет `None`.
- Если заголовок не равен `"Bearer secret-token"`, мы выбрасываем ошибку с кодом 401 (неавторизован).
- `HTTPException` — это способ сообщить пользователю, что что-то пошло не так, например, он не ввёл правильный токен.
- Если всё правильно, пользователь получает сообщение: `{"message": "Access granted"}`.

**Для чего это нужно?**  
Обработчики запросов — это "мозги" вашего приложения. Они решают, что делать с запросом: показать данные, сохранить их или вернуть ошибку. Например, в интернет-магазине обработчик может показать список товаров или проверить, вошёл ли пользователь в систему.

---

#### 3. **Сериализация данных**

**Что это?**  
Сериализация — это процесс преобразования данных, которые вы используете в коде (например, объекты Python), в формат, который понимает клиент (обычно JSON). JSON — это стандартный формат, который выглядит как словарь Python и используется для обмена данными между сервером и клиентом.

**Простыми словами**: это как переводчик, который берёт ваши данные (например, информацию о товаре) и превращает их в понятный для браузера или мобильного приложения вид.

**Пример в FastAPI**:
FastAPI использует библиотеку **Pydantic** для сериализации и проверки данных. Pydantic позволяет заранее определить, какие данные вы ожидаете, и проверяет, что они правильные.

```python
from pydantic import BaseModel, EmailStr

class Item(BaseModel):
    name: str
    price: float
    description: str | None = None
    email: EmailStr | None = None

@app.post("/items/")
async def create_item(item: Item):
    return {"item": item, "status": "created"}
```

**Разберём пример**:
- `class Item(BaseModel)` — создаёт модель данных, где мы описываем, какие поля должен содержать объект `Item`. Например:
  - `name: str` — имя, должно быть строкой.
  - `price: float` — цена, должна быть числом с плавающей точкой.
  - `description: str | None = None` — описание, строка или ничего (`None`).
  - `email: EmailStr | None = None` — email, должен быть валидным адресом (например, `user@example.com`), или ничего.
- `@app.post("/items/")` — говорит FastAPI, что эта функция обрабатывает POST-запросы на `/items/` (POST используется для создания новых данных).
- Когда пользователь отправляет данные, FastAPI проверяет их с помощью Pydantic. Если данные неправильные (например, email невалидный), FastAPI автоматически вернёт ошибку.
- Если данные правильные, функция возвращает их с сообщением `{"status": "created"}`.

**Для чего это нужно?**  
Сериализация гарантирует, что данные, которые вы отправляете или получаете, правильные и в нужном формате. Это как проверка, что все ингредиенты для блюда свежие и подходят для рецепта.

---

#### 4. **Swagger (автоматическая документация)**

**Что это?**  
Swagger — это инструмент, который FastAPI использует для автоматического создания документации для вашего API. Документация — это как инструкция к вашему приложению, которая показывает, какие запросы оно может обработать и как их отправлять.

**Простыми словами**: представьте, что вы написали приложение, но никто не знает, как им пользоваться. Swagger создаёт красивую страницу (по адресу `/docs`), где всё описано, и даже позволяет протестировать запросы прямо в браузере.

**Как это работает?**  
Когда вы запускаете FastAPI-приложение, вы можете открыть в браузере адрес `http://localhost:8000/docs`, и там будет интерактивная страница с описанием всех ваших маршрутов, параметров и примеров ответов.

**Пример кастомизации Swagger**:
```python
app = FastAPI(
    title="My API",
    description="This is a sample API using FastAPI",
    version="1.0.0"
)
```

**Разберём пример**:
- `title="My API"` — задаёт название вашего API, которое будет отображаться в документации.
- `description="This is a sample API using FastAPI"` — описание, чтобы пользователи понимали, для чего ваше API.
- `version="1.0.0"` — версия API, чтобы разработчики знали, с какой версией они работают.

**Для чего это нужно?**  
Swagger делает ваше API понятным для других разработчиков. Это как меню в ресторане, которое показывает, какие блюда можно заказать, и позволяет сразу попробовать, как они "вкусно" работают.

---

### Дополнительные компоненты FastAPI

Чтобы сделать материал ещё более понятным, добавим несколько важных компонентов, которые часто используются в веб-фреймворках и FastAPI.

#### 5. **Middleware**

**Что это?**  
Middleware — это "посредник", который обрабатывает запросы до того, как они попадут в вашу функцию-обработчик, и ответы, прежде чем они отправятся пользователю. Это как фильтр на входе и выходе из вашего приложения.

**Простыми словами**: представьте, что у вас есть охранник на входе в клуб, который проверяет билеты (запросы), и уборщик, который проверяет, всё ли в порядке, перед тем как выпустить гостей (ответы).

**Пример в FastAPI**:
```python
from fastapi import FastAPI
from starlette.middleware.cors import CORS

app = FastAPI()

# Добавляем middleware для разрешения CORS (доступ с других доменов)
app.add_middleware(
    CORS,
    allow_origins=["http://localhost:3000"],  # Разрешённые домены
    allow_credentials=True,
    allow_methods=["*"],  # Разрешённые методы (GET, POST и т.д.)
    allow_headers=["*"],  # Разрешённые заголовки
)

@app.get("/")
async def main():
    return {"message": "Hello from FastAPI"}
```

**Разберём пример**:
- `app.add_middleware(CORS, ...)` — добавляет middleware, которое разрешает запросы с других доменов (например, если ваше API используется фронтендом на React).
- Без CORS браузер может блокировать запросы с другого сайта из-за политики безопасности.
- В данном случае мы разрешаем запросы с `http://localhost:3000` (например, от фронтенда).

**Для чего это нужно?**  
Middleware помогает добавить общие функции, такие как проверка безопасности, логирование запросов или сжатие данных, без необходимости писать это в каждой функции.

---

#### 6. **Зависимости (Dependencies)**

**Что это?**  
Зависимости — это способ вынести общую логику, которая нужна для нескольких маршрутов, в отдельную функцию. Например, проверка авторизации или подключение к базе данных.

**Простыми словами**: это как общий список ингредиентов, который вы используете для приготовления разных блюд. Вместо того чтобы каждый раз искать ингредиенты, вы берёте их из одного места.

**Пример в FastAPI**:
```python
from fastapi import Depends, FastAPI, HTTPException

app = FastAPI()

async def verify_token(token: str = Header(...)):
    if token != "secret-token":
        raise HTTPException(status_code=401, detail="Invalid token")
    return token

@app.get("/secure-data/", dependencies=[Depends(verify_token)])
async def get_secure_data():
    return {"data": "This is secure data"}
```

**Разберём пример**:
- `verify_token` — это функция-зависимость, которая проверяет заголовок `token`.
- `Depends(verify_token)` — говорит FastAPI, что перед выполнением маршрута `/secure-data/` нужно выполнить функцию `verify_token`.
- Если токен неверный, маршрут даже не начнёт выполняться, и пользователь получит ошибку 401.

**Для чего это нужно?**  
Зависимости позволяют повторно использовать код и упрощают поддержку приложения. Например, вы можете проверять токены или подключаться к базе данных в одном месте, а не писать это в каждом маршруте.

---

#### 7. **Работа с базами данных**

**Что это?**  
Большинство веб-приложений работают с базами данных, чтобы хранить информацию (например, список пользователей или товары в магазине). FastAPI не привязан к конкретной базе данных, но часто используется с библиотеками, такими как **SQLAlchemy** (для реляционных баз данных) или **Motor** (для MongoDB).

**Простыми словами**: база данных — это как большой склад, где хранятся все данные вашего приложения, а FastAPI помогает их доставать и обновлять.

**Пример с SQLAlchemy**:
```python
from fastapi import FastAPI
from pydantic import BaseModel
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# Настройка базы данных
DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()

# Модель для базы данных
class UserDB(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    email = Column(String)

Base.metadata.create_all(bind=engine)

# Pydantic модель для валидации
class User(BaseModel):
    name: str
    email: str

app = FastAPI()

@app.post("/users/")
async def create_user(user: User):
    db = SessionLocal()
    db_user = UserDB(name=user.name, email=user.email)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    db.close()
    return {"user": user, "status": "created"}
```

**Разберём пример**:
- Мы создаём базу данных SQLite (простая база данных, которая хранится в файле).
- `UserDB` — это модель для базы данных, которая описывает таблицу `users` с полями `id`, `name` и `email`.
- `User` — это Pydantic-модель, которая проверяет данные, отправленные пользователем.
- Функция `create_user` принимает данные, проверяет их с помощью Pydantic, сохраняет в базу данных и возвращает ответ.

**Для чего это нужно?**  
Базы данных позволяют вашему приложению хранить информацию надолго. Например, в интернет-магазине это могут быть товары, заказы или данные пользователей.

---

### Почему FastAPI подходит для новичков?

1. **Простота**: FastAPI автоматически проверяет данные, создаёт документацию и обрабатывает ошибки, что снижает количество кода, который нужно писать.
2. **Типизация**: благодаря Pydantic вы сразу видите, какие данные ожидаются, и избегаете ошибок.
3. **Асинхронность**: позволяет создавать быстрые приложения, даже если вы не вникаете в детали.
4. **Документация**: Swagger и Redoc (ещё одна документация, доступная по `/redoc`) делают ваше API понятным для всех.

---

**Совет для практики**:
1. Установите FastAPI: `pip install fastapi uvicorn`.
2. Создайте файл `main.py` с примерами из этого материала.
3. Запустите приложение: `uvicorn main:app --reload`.
4. Откройте `http://localhost:8000/docs` и попробуйте отправить запросы через Swagger.


---

## 3. Практический пример: Создание API с FastAPI

### Установка FastAPI
```bash
pip install fastapi uvicorn pydantic
```

### Создание простого API
```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List

app = FastAPI()

class User(BaseModel):
    id: int
    name: str
    email: str

users: List[User] = []  # Симуляция базы данных

@app.get("/users/{user_id}", response_model=User)
async def read_user(user_id: int):
    for user in users:
        if user.id == user_id:
            return user
    raise HTTPException(status_code=404, detail="User not found")

@app.post("/users/", response_model=User)
async def create_user(user: User):
    for existing_user in users:
        if existing_user.id == user.id:
            raise HTTPException(status_code=400, detail="User already exists")
    users.append(user)
    return user

@app.put("/users/{user_id}", response_model=User)
async def update_user(user_id: int, updated_user: User):
    for i, user in enumerate(users):
        if user.id == user_id:
            users[i] = updated_user
            return updated_user
    raise HTTPException(status_code=404, detail="User not found")

@app.delete("/users/{user_id}")
async def delete_user(user_id: int):
    for i, user in enumerate(users):
        if user.id == user_id:
            del users[i]
            return {"detail": "User deleted"}
    raise HTTPException(status_code=404, detail="User not found")
```

### Запуск приложения
```bash
uvicorn main:app --reload
```

### Доступ к документации
- Открыть в браузере: `http://127.0.0.1:8000/docs`.
- Протестировать GET, POST, PUT и DELETE запросы.

