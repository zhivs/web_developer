**Лекция: «Введение в CSS часть 2»**  

### 1. Типографика

Типографика — основа читаемости и визуальной иерархии веб-интерфейсов. CSS предоставляет детальный контроль над каждым аспектом отображения текста.

#### 1.1. Шрифты (`font-family`, `font-size`, `font-weight`, `font-style`)

- **`font-family`** определяет приоритетный список шрифтов. Браузер использует первый доступный. Обязательно указывать общее семейство (`serif`, `sans-serif`, `monospace`) в конце:
  ```css
  body {
    font-family: "Inter", "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  }
  ```
  Без запасного семейства возможен сбой отображения на системах без указанных шрифтов.

- **`font-size`** задаёт размер шрифта. Абсолютные единицы (`px`, `pt`) фиксированы и нарушают масштабируемость. Относительные (`em`, `rem`, `%`) адаптируются:
  - `1em` = размер шрифта родительского элемента.
  - `1rem` = размер шрифта корневого элемента (`<html>`), по умолчанию 16px.
  ```css
  html { font-size: 16px; }
  h1 { font-size: 2rem; }   /* 32px */
  .small { font-size: 0.875rem; } /* 14px */
  ```

- **`font-weight`** управляет насыщенностью. Значения от 100 до 900 с шагом 100. Не все шрифты поддерживают все веса. Например, системный шрифт может не иметь `font-weight: 300`. В таких случаях браузер имитирует начертание, что ухудшает читаемость.

- **`font-style`** переключает между `normal`, `italic` и `oblique`. `italic` использует истинное курсивное начертание шрифта, `oblique` — наклонённое обычное.

#### 1.2. Интерлиньяж и трекинг

- **`line-height`** — ключевой параметр вертикального ритма. Без единицы измерения значение интерпретируется как множитель от `font-size`, что обеспечивает пропорциональность при масштабировании:
  ```css
  p { 
    font-size: 1rem; 
    line-height: 1.5; /* 24px при font-size 16px */
  }
  ```
  Слишком маленькое значение (`<1.2`) ухудшает читаемость; слишком большое (`>1.8`) разрывает связь между строками.

- **`letter-spacing`** (трекинг) регулирует расстояние между символами. Полезен для заголовков:
  ```css
  .hero-title {
    letter-spacing: 0.1em; /* расширенный трекинг */
  }
  .code-inline {
    letter-spacing: -0.02em; /* сжатый трекинг для моноширинных шрифтов */
  }
  ```

- **`word-spacing`** управляет пробелами между словами. Редко используется, но может улучшить компоновку в узких колонках.

#### 1.3. Выравнивание и оформление

- **`text-align`**:  
  - `justify` выравнивает текст по ширине, но может создавать «реки» пробелов. Используется в печатных изданиях, но в вебе — с осторожностью.
  - `start`/`end` — локализованная альтернатива `left`/`right` для языков с RTL-письмом.

- **`text-transform`** полезен для UI-элементов:
  ```css
  .btn-uppercase { text-transform: uppercase; }
  .product-title { text-transform: capitalize; } /* каждое слово с заглавной */
  ```

- **`white-space`**:
  - `pre` сохраняет пробелы и переносы как в HTML `<pre>`.
  - `nowrap` запрещает переносы — используется в навигации или бейджах.
  - `pre-wrap` сохраняет форматирование, но разрешает переносы.

---

### 2. Текстовые эффекты и оформление

#### 2.1. Тени текста (`text-shadow`)

Синтаксис: `смещение-X смещение-Y размытие цвет`. Можно задавать несколько теней через запятую:
```css
.title {
  text-shadow: 
    1px 1px 2px rgba(0,0,0,0.2),
    0 0 10px rgba(255,255,255,0.5);
}
```
Тени улучшают контраст на фоне с переменной яркостью. Например, белый текст на градиенте — без тени может «теряться».

#### 2.2. Декорации (`text-decoration`)

Современные браузеры поддерживают составные свойства:
```css
a {
  text-decoration: underline wavy #ff4757;
}
```
- `text-decoration-thickness` — толщина линии.
- `text-underline-offset` — отступ линии от текста.

Эти свойства позволяют создавать кастомные подчёркивания без псевдоэлементов.

#### 2.3. Цвет текста (`color`)

Цвет должен обеспечивать достаточный контраст (WCAG: ≥ 4.5:1 для обычного текста). Используйте HSL для интуитивной настройки оттенка и яркости:
```css
.error { color: hsl(0, 100%, 45%); }       /* насыщенный красный */
.success { color: hsl(120, 80%, 35%); }    /* тёмно-зелёный */
```

---

### 3. Цвета и градиенты

#### 3.1. Модели цвета

- **HEX**: краткая (`#f00`) и полная (`#ff0000`) формы. Поддерживает альфа-канал в 8-значной форме: `#ff000080` (50% прозрачности).
- **RGB/RGBA**: удобны для программной генерации цветов.
- **HSL/HSLA**: наиболее удобны для дизайнеров: `hsl(240, 100%, 50%)` — чистый синий.

#### 3.2. Градиенты

- **Линейный градиент**:
  ```css
  .btn-gradient {
    background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
  }
  ```
  Угол можно задавать в градусах или ключевыми словами (`to right`, `to bottom left`).

- **Радиальный градиент**:
  ```css
  .spotlight {
    background: radial-gradient(circle at 30% 30%, #ff9a9e, #fad0c4);
  }
  ```
  Позиция центра и форма (`circle`, `ellipse`) настраиваются явно.

- **Конические градиенты** (поддержка: современные браузеры):
  ```css
  .color-wheel {
    background: conic-gradient(
      red, orange, yellow, green, blue, indigo, violet, red
    );
  }
  ```

---

### 4. Границы и закругления

#### 4.1. Границы (`border`)

Полная запись:
```css
.border-example {
  border-width: 3px;
  border-style: dashed;
  border-color: #2ecc71;
}
```
Можно задавать разные стили для каждой стороны:
```css
.notification {
  border-left: 4px solid #e74c3c;
  border-top: 1px solid #eee;
}
```

#### 4.2. Закругления (`border-radius`)

Поддерживает эллиптические углы:
```css
.pill {
  border-radius: 20px / 10px; /* горизонтальный / вертикальный радиус */
}
```
Максимальное закругление для круга: `border-radius: 50%`. Для овала — `border-radius: 50% / 30%`.

---

### 5. Фоновые изображения и свойства `background`

#### 5.1. Составные свойства

- **`background-size: cover`** масштабирует изображение с сохранением пропорций, заполняя весь контейнер (часть может обрезаться).
- **`background-size: contain`** помещает изображение целиком, возможны пустые области.
- **`background-position: center`** — стандарт для hero-секций.

#### 5.2. Множественные фоны

Можно накладывать несколько фонов:
```css
.striped-bg {
  background:
    linear-gradient(rgba(255,255,255,0.1) 50%, transparent 50%),
    url("texture.png");
  background-size: 100% 40px, cover;
}
```

---

### 6. Работа с изображениями

#### 6.1. Элемент `<img>`

- Всегда указывайте `width` и `height` в HTML для предотвращения сдвигов макета при загрузке:
  ```html
  <img src="photo.jpg" alt="Описание" width="640" height="480">
  ```
  Браузер зарезервирует место до загрузки.

#### 6.2. Адаптивные изображения

Используйте `srcset` и `<picture>` для разных разрешений:
```html
<img
  src="photo-800.jpg"
  srcset="photo-400.jpg 400w, photo-800.jpg 800w, photo-1200.jpg 1200w"
  sizes="(max-width: 600px) 100vw, 50vw"
  alt="...">
```

#### 6.3. Фон vs `<img>`

- **Фон**: декор, не несёт смысла (узор, градиент).
- **`<img>`**: семантически значимый контент (фото продукта, логотип).

---

### 7. Обтекание текста и скролл

#### 7.1. Обтекание (`float`)

Хотя устарело, встречается в легаси-коде:
```css
.figure {
  float: right;
  margin: 0 0 1em 1em;
}
.text::after {
  content: "";
  display: table;
  clear: both;
}
```
Современная альтернатива — `shape-outside` с `float` для сложных контуров:
```css
.circle-img {
  float: left;
  shape-outside: circle(50%);
  width: 200px;
  height: 200px;
}
```

#### 7.2. Скролл

- `overflow: auto` добавляет скролл только при необходимости.
- Для горизонтального скролла контента (например, карусель):
  ```css
  .scroll-container {
    display: flex;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch; /* плавный скролл на iOS */
  }
  ```
- Скрытие скроллбара без потери функциональности:
  ```css
  .hide-scrollbar {
    scrollbar-width: none; /* Firefox */
  }
  .hide-scrollbar::-webkit-scrollbar {
    display: none; /* Chrome, Safari */
  }
  ```

---

### 8. Правила CSS

#### 8.1. Синтаксис и структура

Каждое правило состоит из селектора и блока объявлений. Допустимы многострочные значения:
```css
.grid {
  background:
    linear-gradient(45deg, rgba(255,0,0,0.2), transparent),
    linear-gradient(-45deg, rgba(0,255,0,0.2), transparent);
}
```

#### 8.2. Специфичность

Формула: `(A, B, C, D)`, где:
- A — инлайновые стили (`style=""`)
- B — количество ID
- C — количество классов, атрибутов, псевдоклассов
- D — количество тегов и псевдоэлементов

Пример:
```css
#nav .item:hover  → (0, 1, 2, 0)
div.item          → (0, 0, 1, 1)
```
Первое правило имеет больший приоритет.

#### 8.3. Каскад

Порядок применения:
1. Специфичность
2. Порядок в коде (последнее объявление побеждает)
3. `!important` (нарушает естественный каскад — использовать только в крайних случаях)

---

### 9. CSS Code Style

#### 9.1. Принципы

- **Единообразие**: все разработчики проекта следуют одному стилю.
- **Читаемость**: код должен быть понятен без комментариев.
- **Поддерживаемость**: легко вносить изменения без побочных эффектов.

#### 9.2. Рекомендации

- Используйте осмысленные имена классов: `.user-avatar`, а не `.img1`.
- Группируйте свойства логически:
  ```css
  .card {
    /* Позиционирование */
    position: relative;
    top: 0;

    /* Блочная модель */
    width: 100%;
    padding: 1rem;
    margin-bottom: 1rem;

    /* Визуальные свойства */
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);

    /* Типографика */
    font-size: 1rem;
    line-height: 1.5;
  }
  ```

- Избегайте избыточных значений:
  ```css
  /* Плохо */
  margin: 10px 10px 10px 10px;
  /* Хорошо */
  margin: 10px;
  ```

#### 9.3. Инструменты автоматизации

- **Prettier**: форматирование с фиксированными правилами.
- **Stylelint**: проверка на ошибки и несоответствие стилю:
  ```json
  {
    "rules": {
      "declaration-block-trailing-semicolon": "always",
      "color-hex-length": "short",
      "selector-class-pattern": "^[a-z][a-z0-9-]+$"
    }
  }
  ```

### 10. Поток документа (Document Flow)

Поток документа — это естественный порядок размещения элементов в HTML-документе, определяемый спецификацией CSS. Все элементы по умолчанию участвуют в нормальном потоке, если явно не извлечены из него (например, через `position: absolute` или `float`).

#### 10.1. Типы потоков

Согласно спецификации CSS Display Module Level 3, выделяют три основных типа потоков:

1. **Нормальный поток (Normal Flow)**  
   Элементы располагаются последовательно: блочные — сверху вниз, строчные — слева направо в пределах строки. Это поведение по умолчанию.

2. **Поток с плавающими элементами (Float Flow)**  
   Элементы с `float` смещаются влево или вправо, а контент обтекает их. Требует управления потоком (очистки) для предотвращения коллапса родителя.

3. **Абсолютный поток (Absolute Positioning Flow)**  
   Элементы с `position: absolute` или `fixed` извлекаются из нормального потока и позиционируются относительно ближайшего позиционированного предка (или viewport для `fixed`).

> **Важно**: Современные макеты всё чаще строятся без `float` и `absolute` в пользу Flexbox и Grid, которые работают **внутри** нормального потока.

#### 10.2. Контексты форматирования (Formatting Contexts)

Контекст форматирования — это область, в которой браузер размещает и отображает элементы. Основные типы:

- **Block Formatting Context (BFC)**  
  Создаётся при:
  - `overflow` ≠ `visible`
  - `display: flow-root`
  - `float` ≠ `none`
  - `position` = `absolute` / `fixed`
  - `display: inline-block`, `table-cell`, `flex`, `grid` и др.

  Свойства BFC:
  - Элементы внутри не взаимодействуют с плавающими элементами снаружи.
  - Отменяют схлопывание внешних отступов (margin collapse) между родителем и потомками.
  - Родитель «обёртывает» плавающие дочерние элементы.

  Пример решения проблемы коллапса высоты у родителя с `float`:
  ```css
  .container {
    display: flow-root; /* создаёт BFC */
  }
  .item {
    float: left;
  }
  ```

- **Inline Formatting Context (IFC)**  
  Применяется к строчным элементам внутри блока. Управляет размещением текста, пробелов, переносов.

- **Flex/Grid Formatting Contexts**  
  Полностью заменяют BFC/IFC внутри контейнера. Элементы больше не подчиняются правилам нормального потока.

---

### 11. Блочная модель (Box Model)

Блочная модель — фундаментальная концепция CSS, описывающая, как каждый элемент представлен как прямоугольная коробка, состоящая из четырёх слоёв:

1. **Контент (content)** — фактическое содержимое (текст, изображение).
2. **Поля (padding)** — внутренний отступ между контентом и границей.
3. **Граница (border)** — рамка вокруг padding.
4. **Внешний отступ (margin)** — прозрачное пространство снаружи границы, отделяющее элемент от соседей.

#### 11.1. Стандартная блочная модель (`box-sizing: content-box`)

По умолчанию (`content-box`) свойства `width` и `height` задают **только размер контента**. Итоговая ширина элемента рассчитывается как:

```
Итоговая ширина = width + padding-left + padding-right + border-left + border-right + margin-left + margin-right
```

Пример:
```css
.box {
  width: 200px;
  padding: 20px;
  border: 5px solid black;
  margin: 10px;
}
```
Фактическая занимаемая ширина = 200 + 40 + 10 + 20 = **270px**.

Это приводит к неожиданному поведению при адаптивной вёрстке: добавление `padding` ломает макет.

#### 11.2. Альтернативная блочная модель (`box-sizing: border-box`)

При `box-sizing: border-box` свойства `width` и `height` включают **контент, padding и border**. Margin остаётся снаружи.

Итоговая ширина = `width` (уже включает padding и border) + `margin-left` + `margin-right`.

Тот же пример:
```css
.box {
  box-sizing: border-box;
  width: 200px;
  padding: 20px;
  border: 5px solid black;
  margin: 10px;
}
```
Фактическая ширина = **200px** (контент сжимается до 150px), а занимаемое место = 200 + 20 = **220px**.

> **Рекомендация**: Применяйте `box-sizing: border-box` глобально:
> ```css
> *, *::before, *::after {
>   box-sizing: border-box;
> }
> ```
> Это стандарт де-факто в профессиональной вёрстке.

#### 11.3. Визуализация блочной модели

Для отладки используйте инструменты разработчика в браузере (DevTools → Elements → Styles → Box Model). Также можно временно назначить цвета:
```css
* {
  outline: 1px solid red; /* не влияет на поток, в отличие от border */
}
```

#### 11.4. Схлопывание внешних отступов (Margin Collapse)

В нормальном потоке вертикальные `margin` соседних блочных элементов **схлопываются**: итоговый отступ равен **максимальному** из них, а не сумме.

Пример:
```html
<p style="margin-bottom: 20px;">Абзац 1</p>
<p style="margin-top: 30px;">Абзац 2</p>
```
Расстояние между абзацами = **30px**, а не 50px.

Схлопывание также происходит между:
- Первым/последним дочерним элементом и его родителем (если у родителя нет `padding`, `border`, BFC).
- Пустым блоком (margin-top и margin-bottom схлопываются).

**Как отключить схлопывание**:
- Создать BFC у родителя (`overflow: hidden`, `display: flow-root`).
- Добавить `padding` или `border` у родителя.
- Использовать `flex` или `grid` — в этих контекстах схлопывание **не происходит**.

---

> Понимание нормального потока и блочной модели — обязательное условие для предсказуемой вёрстки.   Большинство «странного поведения» CSS объясняется либо нарушением ожиданий относительно потока, либо непониманием расчёта размеров при `content-box`. Использование `box-sizing: border-box` и осознанное управление контекстами форматирования (особенно BFC) позволяет избежать 90% типичных ошибок начинающих разработчиков.

Эти концепции лежат в основе всех современных методов компоновки — от классических блоков до Flexbox и Grid. Без их освоения невозможно эффективное применение продвинутых инструментов CSS.
